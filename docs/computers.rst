============================================================
 How to give and get computer support from a complete twat*
============================================================

OK.  You love each other, Uncle's Love Birds.

And you do and how.

And you are turning into each other and into your mum's and dad's.

And siblings and others and more.

So computers.  Hate them or hate them?

So here I am ::

  from math import e
  from import datetime import datetime
  
  how_long = datetime.now().year() - 1985 + e

  print("%f how_long {}".years()


So there seem to be some problems in this area.

So problem seems to be in the i/O module.

There's a race condition on the input pipes.

So you feed it a sliver of fish it zooms off into the distance
like Pyree the cat (btw he's cool about how you spell his name, so
fill your boots there) when a tiny scared kitten.

And then retreats where it focusses entirely on elaborate plans for
the new morcel.

Now where was I?

OK.  So small amount of input off it zooms.  But it then starts
throwing out ideas like a robot on speed trying to learn how to throw
frisbees.

And it seems to have a special focus throwing ideas at you?

But it gets really weird when its focussing its eyes on computer
screens.

And fingers on a keyboard.

And then the ears shut down almost entirely.   Now this is not to say
the ears were ever really working in the first place.

btw why doesn't my guitar have a head shaped hole in it?  And some
frantic scribbling about pi from america?

I digress.  The stack gets deeper and deeper.

It may try to use you as sort of an auxillary stack.  [I should get
Dave to implement a version of how all this works].

It's neat.  It is some thing like::

  from random import random
  
  from curio import UniversalQueue, sleep

  # one of these should come in handy:
  uq = UniversalQueue()

  for lfi in latest_fine_idea_hosepipe():
      uq.push(lfi)

      while True:
         lfi = lfi + latest_fine_idea_hosepipe()
         lfi.enance_and_broadcast()

         if random.random() < epsilon:
            sleep()

         if random.random() < p:
            # take a short recording, listen to something
            p_tape()


So basically, this is the frisbee flinging lfi's instead of actual
frisbees.   If you have a robot and frisbees, stand well back.

See back in 1985 I went on a 3 day introduction to Unix course at
an Arts and technology school.

3 days in a different office do this new fangled unix stuff.

Now the course was a mixture of weird adventure: file permissions,
seeing how the group thing did and didn't or did work.

But then we spent about half aday learning this weird stuff called
emacs which required your nose attached to this weird control key on
this keyboard that was also weird.

Lots of strangeness.   But the thing I hated most was emacs.

Until a couple of years later.  Boom unix arrived in the form of Sun
workstations.    Should check out the specs of the early machines.

They seemed like magic.   And had this thing called emacs.

And I had a colleague who showed me how to do 3 cool tricks, told me
the best plan B was some goofy thing called vi and that anyway emacs
could emulate vi so what's the point?

And I am still using emacs now.

I can relax and type and mostly focus on what I am typing.

Now we have git too.

And it has taken time but commiting early and often seems to work well.

Now there are two other tools that have stayed with me through the
years.

bash
====

Bourne Again SHell.

I think my first bash adventure may have been in Canada.  It is a long
time ago.

The man page, of course, if you want the best man for a job, you need
to do M-x woman whilst in emacs (you aren't running vi are you?)


vi
==

If you are running vi then I hear vim is better than good.  Mum always
reckoned Vim was good in the kitchen.  Not to be confused with vimto,
which intriguingly is an anagram of vomit.

So, as I said, if you are using vim (basically you have syntax
highlighting).


idle
====

Idle?  No busy typling.

Guido wrote IDLE and you can launch it with e for Eric from karmapi
gui's.

Tankrain is the best.  It is slow as molasses due to massive over
engineering that supports other stuff some of which works.

Any I used Idle for a good while and when writing code I find it
changes the way I focus in ways I like.

I still wonder if there are more adventures to come with Eric and
IDLE.

What about Word?
================

Shivers

Did someone say Antiword?
=========================

::
   
  antiword/artful 0.37-11 amd64
    Converts MS Word files to text, PS, PDF and XML

An Irish connection too and lots of tales here.

But most of all, why didn't I think of this sooner.


libre office
============



True love
=========

gnumeric

python

Matplotlib, Jupyter <3 00 <3

Eagle and Salmon, guiding each other.

Watching and listening too.  I'm up in the mountains, flying high
and the water is clearing from my ears.

We have the music, just no CD player.

And that's just cool for now.

Because of four classic books and an infinite love.

Whatever happened to..
======================

Matplotlib plots embedded in gnumeric?

And python in gnumeric?

And herein lies a cool thing... I could look and see what's there if
it were installed in a base Ubuntu system... checks::

  It's not there :(

If I had a web connection.  Which I could, but actually enjoying it
not there for now, so one for another day.

Did someone say webform?
========================

Leaves the room

Tech paranoia
=============

Much of life writing with software has been life with stuff that does
not yet do what is desired.

When you find a great tool stick with it, you may not need much more.

Hence:

   * Excel
     
   * Word
     
   * Powerpoing

   * ripl, tankrain or just PIL + feh or gqview or ....

But, whatabout?
===============

Yes, there is no shortage of fantastic tools.  And that is good.

So what's the problem?
======================

Languages.


But what about Machine Learning and Block Chain?
================================================

There's an idea: un block chain, ubc.

An we are back to C.

Which is sort of how it all began.

And pretty much every important problem was already solved by then, at
least theoretically.

And now everyone has a Cray in their pocket.

Or not quite everyone.

And that can be a problem.

And everyone who has one has to re-learn how to answer the phone every
time there is an upgrade.

Oh and this one is a wonder to behold::

              PLEASE DON'T
              
              REMOVE CARD


Stress and using stuff that might explode
=========================================

Aside::

  import hypothesis

  # great talk, might have been lighning

  def test_does_it_explode(thing):
      """  Prod it see what happens
      
      This is also known as the "pyree protocol" or prp for short.

      Pyree says it is pronounced perp as in walk.  He's pretty
      advanced speech wise for a one year old.  Particularly when you
      factor in he's really still a kitten.
      
      So protocol not advised in presense of moose.

      See also title of this piece, whatever it is.
      """

OK.  So this is actually a great test to have.

Just checked karmapi.  Oh, I did write some tests.... over to bash

::

   grep explod tests/test*.py


Hmm... no explode test yet.  Maybe we need Eric?

